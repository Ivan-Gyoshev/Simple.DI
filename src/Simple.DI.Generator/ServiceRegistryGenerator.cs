using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace Simple.DI.Generator;

[Generator]
public sealed class ServiceRegistryGenerator : IIncrementalGenerator
{
    private const string _attributeName = "ServiceAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<Target> services = context.SyntaxProvider.CreateSyntaxProvider
           (
            predicate: static (syntaxNode, _) => syntaxNode.IsClassDeclaration(),
            transform: (generatorContext, cn) => GetTarget(generatorContext, cn)
           ).Where(static target => target.IsValid);

        context.RegisterSourceOutput(services.Collect(), Execute);
    }

    private void Execute(SourceProductionContext context, ImmutableArray<Target> args)
    {
        try
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            StringBuilder registryBuilder = new();

            registryBuilder.Append($@"// <auto-generated />
// IMPORTANT: This class is auto-generated!

using Microsoft.Extensions.DependencyInjection;

namespace Simple.DI
{{
    public static class ServiceRegistrator
    {{
        public static IServiceCollection RegisterResolvableServices(this IServiceCollection services)
        {{
");
            foreach (Target target in args)
            {
                registryBuilder.AppendLine(target.TransformToServiceDescriptor());
            }

            registryBuilder.Append(@$"
            return services;
        }}
    }}
}}");

            string registry = registryBuilder.ToString();
            context.AddSource("ServiceRegistry.g.cs", SourceText.From(registry, Encoding.UTF8));
        }
        catch (Exception ex)
        {
            ILogger logger = new DiagnosticLogger(context);
            logger.LogError($"Message: {ex.Message}, Trace: {ex.StackTrace}");
        }
    }

    private static Target GetTarget(GeneratorSyntaxContext generatorContext, CancellationToken token)
    {
        try
        {
            ClassDeclarationSyntax syntax = (ClassDeclarationSyntax)generatorContext.Node;
            ISymbol classSymbol = generatorContext.SemanticModel.GetDeclaredSymbol(syntax, token);

            if (classSymbol.IsAbstract)
                return Target.Invalid;

            AttributeData attribute = GetClassAttribute(classSymbol);
            if (attribute is null)
                return Target.Invalid;

            TypedConstant lifetime = attribute.ConstructorArguments[0];
            TypedConstant serviceInterface = attribute.ConstructorArguments[1];

            InterfaceData interfaceData = generatorContext.FindInterfaceData(serviceInterface);

            return new Target((string)lifetime.Value, classSymbol.Name, classSymbol.ContainingNamespace.ToDisplayString(), interfaceData.Name, interfaceData.ContainingNamespace);
        }
        catch
        {
            return Target.Invalid;
        }
    }

    private static AttributeData GetClassAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes()
                .Where(atr => atr.AttributeClass.Name.Equals(_attributeName))
                .SingleOrDefault();
    }
}

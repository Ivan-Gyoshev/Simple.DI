using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Simple.DependencyInjection.Generator.Models;
using System.Collections.Immutable;
using System.Text;

namespace Simple.DependencyInjection.Generator;

[Generator]
public sealed class ServiceRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<Service> services = context.SyntaxProvider.CreateSyntaxProvider
           (
            predicate: static (syntaxNode, _) => syntaxNode.IsClassDeclaration(),
            transform: (generatorContext, cn) => GetTarget(generatorContext, cn)
           ).Where(static target => target.IsValid);

        context.RegisterSourceOutput(services.Collect(), Execute);
    }

    private void Execute(SourceProductionContext context, ImmutableArray<Service> args)
    {
        try
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            StringBuilder registryBuilder = new();

            registryBuilder.Append($@"// <auto-generated />
// IMPORTANT: This class is auto-generated!

using Microsoft.Extensions.DependencyInjection;

namespace Simple.DependencyInjection
{{
    public static class ServiceRegistrator
    {{
        public static IServiceCollection RegisterResolvableServices(this IServiceCollection services)
        {{
");
            foreach (Service target in args.OrderBy(x => x.Lifetime))
            {
                registryBuilder.AppendLine(target.TransformToServiceDescriptor());
            }

            registryBuilder.Append(@$"
            return services;
        }}
    }}
}}");

            string registry = registryBuilder.ToString();
            context.AddSource("ServiceRegistry.g.cs", SourceText.From(registry, Encoding.UTF8));
        }
        catch (Exception ex)
        {
            ILogger logger = new DiagnosticLogger(context);
            logger.LogError($"Message: {ex.Message}, Trace: {ex.StackTrace}");
        }
    }

    private static Service GetTarget(GeneratorSyntaxContext generatorContext, CancellationToken token)
    {
        try
        {
            ClassDeclarationSyntax syntax = (ClassDeclarationSyntax)generatorContext.Node;
            ISymbol classSymbol = generatorContext.SemanticModel.GetDeclaredSymbol(syntax, token);

            if (classSymbol.IsAbstract)
                return Service.Invalid;

            AttributeData attribute = GetAttributeData(classSymbol);
            if (attribute is null)
                return Service.Invalid;

            TypedConstant lifetime = attribute.ConstructorArguments[0];
            TypedConstant serviceInterface = attribute.ConstructorArguments[1];

            ParentInterfaceData interfaceData = generatorContext.FindInterfaceData(serviceInterface);
            ServiceType type = ResolveType(attribute.AttributeClass.Name);

            if (type == ServiceType.Invalid)
                return Service.Invalid;

            return new Service((string)lifetime.Value, classSymbol.Name, classSymbol.ContainingNamespace.ToDisplayString(), interfaceData.Name, interfaceData.ContainingNamespace, type);
        }
        catch
        {
            return Service.Invalid;
        }
    }

    private static AttributeData GetAttributeData(ISymbol symbol)
    {
        return symbol.GetAttributes()
                .Where(atr => atr.AttributeClass.Name.Equals(GeneratorConstants.ServiceAttribute) ||
                              atr.AttributeClass.Name.Equals(GeneratorConstants.OpenGenericServiceAttribute))
                .SingleOrDefault();
    }

    private static ServiceType ResolveType(string attributeName) => attributeName switch
    {
        GeneratorConstants.ServiceAttribute => ServiceType.Regular,
        GeneratorConstants.OpenGenericServiceAttribute => ServiceType.OpenGeneric,
        _ => ServiceType.Invalid
    };
}
